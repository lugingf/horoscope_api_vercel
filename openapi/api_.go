/*
Horoscope API

The Horoscope API offers a versatile solution for accessing daily, weekly, and monthly horoscope predictions tailored to each zodiac sign. With intuitive endpoints and a straightforward interface, developers can seamlessly integrate astrological insights into their applications. Whether providing users with daily guidance, weekly trends, or monthly forecasts, this API delivers accurate and personalized horoscope data in JSON format. Built on reliable infrastructure, the API ensures scalability and reliability, enabling it to handle varying levels of demand with minimal downtime. With customizable parameters, developers can fine-tune requests to meet specific requirements, enhancing user experiences with tailored astrological content. Comprehensive documentation accompanies the API, providing developers with all the information needed to integrate horoscope data seamlessly. Start leveraging the Horoscope API today to empower users with personalized astrological insights that resonate with their individual zodiac signs and life experiences.

API version: 2.0.2
Contact: ashutoshbritish@gmail.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiGetDailyHoroscopeApiRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	sign *string
	day *string
}

func (r ApiGetDailyHoroscopeApiRequest) Sign(sign string) ApiGetDailyHoroscopeApiRequest {
	r.sign = &sign
	return r
}

// Accepted values: Date in format (YYYY-MM-DD) OR \&quot;TODAY\&quot; OR \&quot;TOMORROW\&quot; OR \&quot;YESTERDAY\&quot;.
func (r ApiGetDailyHoroscopeApiRequest) Day(day string) ApiGetDailyHoroscopeApiRequest {
	r.day = &day
	return r
}

func (r ApiGetDailyHoroscopeApiRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetDailyHoroscopeApiExecute(r)
}

/*
GetDailyHoroscopeApi Method for GetDailyHoroscopeApi

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDailyHoroscopeApiRequest
*/
func (a *DefaultApiService) GetDailyHoroscopeApi(ctx context.Context) ApiGetDailyHoroscopeApiRequest {
	return ApiGetDailyHoroscopeApiRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) GetDailyHoroscopeApiExecute(r ApiGetDailyHoroscopeApiRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetDailyHoroscopeApi")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/get-horoscope/daily"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sign == nil {
		return nil, reportError("sign is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "sign", r.sign, "")
	if r.day != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "day", r.day, "")
	} else {
		var defaultValue string = "TODAY"
		r.day = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetMonthlyHoroscopeApiRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	sign *string
}

func (r ApiGetMonthlyHoroscopeApiRequest) Sign(sign string) ApiGetMonthlyHoroscopeApiRequest {
	r.sign = &sign
	return r
}

func (r ApiGetMonthlyHoroscopeApiRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetMonthlyHoroscopeApiExecute(r)
}

/*
GetMonthlyHoroscopeApi Method for GetMonthlyHoroscopeApi

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMonthlyHoroscopeApiRequest
*/
func (a *DefaultApiService) GetMonthlyHoroscopeApi(ctx context.Context) ApiGetMonthlyHoroscopeApiRequest {
	return ApiGetMonthlyHoroscopeApiRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) GetMonthlyHoroscopeApiExecute(r ApiGetMonthlyHoroscopeApiRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetMonthlyHoroscopeApi")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/get-horoscope/monthly"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sign == nil {
		return nil, reportError("sign is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "sign", r.sign, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetWeeklyHoroscopeApiRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	sign *string
}

func (r ApiGetWeeklyHoroscopeApiRequest) Sign(sign string) ApiGetWeeklyHoroscopeApiRequest {
	r.sign = &sign
	return r
}

func (r ApiGetWeeklyHoroscopeApiRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetWeeklyHoroscopeApiExecute(r)
}

/*
GetWeeklyHoroscopeApi Method for GetWeeklyHoroscopeApi

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetWeeklyHoroscopeApiRequest
*/
func (a *DefaultApiService) GetWeeklyHoroscopeApi(ctx context.Context) ApiGetWeeklyHoroscopeApiRequest {
	return ApiGetWeeklyHoroscopeApiRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) GetWeeklyHoroscopeApiExecute(r ApiGetWeeklyHoroscopeApiRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetWeeklyHoroscopeApi")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/get-horoscope/weekly"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sign == nil {
		return nil, reportError("sign is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "sign", r.sign, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
